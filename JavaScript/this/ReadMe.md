# 01. this 키워드

자바나 C++ 같은 클래스 기반 언어에서 this는 언제나 클래스가 생성하는 인스턴스를 가리킨다. 하지만 자바스크립트의 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다. 또한 strict mode(엄격모드) 역시 this 바인딩에 영향을 준다.

# 02. 일급 객체

일급객체인 자바스크립트 함수는 변수나 데이터에 할당할 수 있고 다른 함수에 인수 또는 반환값으로도 사용할 수 있다.

1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.

      `const myFunc = func`

3. 함수의 매개변수에 전달할 수 있다.

      `function func1(func2) { }`

4. 함수의 반환 값으로 사용할 수 있다.

      `function func1() {
        return func1
      }`

이런 특징 때문에 자바스크립트 함수는 다양한 환경에서 호출될 수 있다.

단독으로 호출 되는 것은 물론, 특정 개체에 메소드로 호출되기도 하고 심지어는 동일한 함수가 서로 다른 객체에 의해서 호출 되기도 한다. 
때문에 자바스크립트 함수에서 this를 자기 자신이라고 표현하기는 어렵다.

1. 단독으로 호출 

func()

2. 특정 객체의 메소드로 호출 

유정.func()

3. 동일한 함수가 다른 객체에 의해 호출

감자.func()

함수가 선언된 후 어떤 환경에서 어떤 객체에 의해 호출되었는지 예측할 수 없기 때문이다.

완벽하게 같은 함수라도 어떤 실행 환경에서 쉽게 말해 어떤 객체에 의해 호출되느냐에 따라 this의 의미가 달라진다.

자바스크립트에서 모든 함수는 this를 가지고 있다. 그리고 함수가 호출되면 그때 그때 상황에 따라 this가 가리키는 객체가 결정된다.

이렇게 함수가 호출될 때마다 this가 동적으로 결정되는 것을 **‘this가 그 객체에 바인딩 된다’** 라고 표현한다.

### Object.Function()

일반적으로 this는 점 앞에 있는 객체. 즉 호출 당시 함수를 포함하고 있는 객체에 바인딩 된다.

# 3. This Binding Rules

사실 각 실행 문맥에서 this를 바인딩하는 데에는 일정한 규칙들이 존재한다.

this는 기본적으로 네가지 규칙에 의해서 바인딩된다.

1. 일반적 바인딩
    - 일반 함수 호출
2. 암시적 바인딩
    - 메서드 호출
3. new 바인딩
    - 생성자 함수 호출
4. 명시적 바인딩
    - Function.prototype.qpply/call/bind 메서드에 의한 간접 호출

이 규칙들 사이에는 분명하게 우선순위가 존재한다.

## 일반적 바인딩

```jsx
function showThis() {
  console.log(this)
}
function showThisStricMode() {
  'use strict'
  console.log(this)
}
showThis() // window
showThisStricMode() // undefined
```

![image](https://user-images.githubusercontent.com/88040809/210537409-38ea3a78-b3c4-4af7-a351-99feaef20a52.png)

### 일반 함수 호출(브라우저 실행 환경)

자바스크립트 호출을 하는 가장 기본적인 방법은 바로 단독 실행하는 것이다.
함수를 단독 실행하게 되면 this는 기본적으로 전역 객체에 바인딩된다.
따라서 브라우저 실행 환경에서는 전역 객체인 윈도우객체에 바인딩된다. 

### Strict mode

주의해야 할 점은 use strict 키워드를 통해 엄격 모드(Strict mode)를 사용하게 되면 전역 객체가 이제 바인딩 대상에서 아예 제외된다. 
따라서 이 경우에는 this가 바인딩될 객체가 존재하지 않기 때문에 undefined 값을 가지게 된다.
생성자 함수가 아닌 일반 함수 내부에서는 this를 사용할 필요가 없기 때문이다.

```jsx
function showThis() {
  console.log(this)
}

showThis(); // object [global]
console.log(this); // {}
console.log(this === module.exports); // true
```

![image](https://user-images.githubusercontent.com/88040809/210537635-e5762b77-2a1b-498c-9da2-4567f69a9755.png)

### 일반 함수 호출(Node.js 환경)

노드 환경에서도 마찬가지로 this가 전역객체에 바인딩 된다. 노드의 전역객체는 글로벌이므로 글로벌 객체에 바인딩된다. 

노드 환경에서는 그때 그때 상황에 따라 다르게 바인딩 되는 경우가 있는데 함수코드 안에서가 아니라 전역 코드상에서 this를 이제 콘솔에 한번 출력을 해보면 빈 객체가 나오게 된다. 이 빈 객체는 사실 모듈 객체에 있는 exports 객체와 완벽하게 동일한 객체이다. 

이를 통해서 Node.js 환경에서 this가 두 가지 방향으로 바인딩 되는 것을 알 수가 있다. 

## 암시적 바인딩

```jsx
const obj = {
  name: 'youjung',
  getName() {
    return this.name;
  },
};
console.log(obj.getName()); // youjung
```

자바스크립트의 함수는 단독으로 호출될 수 있을 뿐만 아니라 객체의 메소드로도 호출이 된다. 이 경우 this가 점 바로 앞에 있는 객체에 바인딩된다. 그리고 이렇게 바인딩되는 방식을 암시적 바인딩이라고 부른다.

그런데 암시적 바인딩이 되는 경우에서 함수를 사용할 때에는 조금 조심해야 될 부분이 있다.

```jsx
const obj = {
  name: 'youjung',
  getName() {
    return this.name;
  },
};

function showReturnValue(callback) {
  console.log(callback());
}

showReturnValue(obj.getName); // undefined
```

![image](https://user-images.githubusercontent.com/88040809/210537742-e81564dd-9f91-4c59-bb5d-5f19b106bafe.png)

만약 여기서 showReturnValue에다가 obj.getName을 인수로 넘기면 getName 함수가 getName앞에 있는 객체가 obj이기 때문에 그 안에서의 this가 obj에 바인딩 되어야 될 것 같은데 실제로 프로그램을 실행해보면 이상하게도 undefined가 출력된다.

자바스크립트에서 객체를 할당한 변수는 해당 객체에 대한 참조값을 저장한다. obj.getName프로퍼티에는 getName 함수에 대한 참조가 들어 있다.

그리고 참조값을 함수의 인수로 넘기게 되면 함수는 이 참조값을 복제해서 사용을 하게 된다. 따라서 같은 객체를 참조하는 또 다른 변수를 만들어서 함수 안에서 사용하게 된다.

마찬가지로 showReturnValue에서 obj.getName을 전달하면 동일한 함수를 참조하는 또 다른 reference가 콜백 변수에 저장 되어서 사용 되는 것이다.

obj.getName과 콜백이 완벽하게 동일한 함수를 참조하고 있고 마찬가지로 동일한 방식으로 괄호를 붙여서 함수를 호출하고 있는데 누구는 암시적 바인딩이 되고 한 번이라도 복제가 일어나고 다른 변수를 거치면 감쪽같이 바인딩이 안되는 상황이다.

```jsx
object.function()
// 참조 타입(Reference Type)
```

이유는 점 연산에 있다. 점연산이나 대괄호 연산을 통해서 객체의 프로퍼티에  접근하면 참조 타입이라고 하는 특별한 값을 반환 해준다. 

### 참조 타입 (Reference Type)

```jsx
(base, name, strict)
base: 객체
name: 프로퍼티 이름
stric: 엄격모드 true
```
![image](https://user-images.githubusercontent.com/88040809/210537838-4635579e-0632-4954-b258-8ae0bcabcab1.png)

참조 타입은 자바스크립트 명세서에서만 사용되는 타입인데 프로퍼티 뿐만 아니라 프로퍼티를 가지고 있는 객체와 strict 모드인지 아닌지에 대한 여부를 같이 가지고 있는 일종의 하나의 타입이다.

예를 들어서 엄격 모드에서 obj.getName에 접근을 하면 `obj.getName: (obj. getName. true)` 다음과 같은 참조 타입을 얻게 된다.

참조 타입에 바로 괄호를 붙여서 함수를 호출하게 되면 그 함수 안에 있는 this가 참조타입에 있는 객체를 찾아서 바인딩된다. 이러한 바인딩 방식을 **암시적 바인딩**이라고 부른다.

```jsx
obj.getName(); // 참조 타입을 통해 암시적 바인딩
function showReturnValue(callback) { // 함수의 참조값만 전달
  callback(); // 함수 단독 실행
}
```

그런데 점 연산이나 대괄호 연산을 제외한 다른 연산들은 참조 타입이 아닌 해당 프로퍼티의 값만 전달하게 된다. 따라서 아무리 점연산을 통해 참조 타입을 얻어냈다고 하더라도 다른 변수에 할당을 하는 순간 프로퍼티의 값 혹은 그 프로퍼티가 참조하고 있는 이제 그 참조값만 남게 된다.

따라서 점연산을 통해 얻은 값은 바로 함수로 호출 하지 않고서는 우리가 암시적 바인딩을 기대할 수가 없다. 마찬가지로 인수로 전달된 콜백의 참조도 객체에 대한 어떠한 정보도 포함을 하지 않기 때문에 함수로 단독 호출한 것과 같이 동작을 하게 된다. 

## 명시적 바인딩

그렇게 되면 바인딩된 this를 너무 쉽게 잃어버리는 문제생긴다. 이를 해결하기 위해서는 

다행히 자바스크립트에는 this를 특정 객체에 암시적으로 바인딩할 뿐만 아니라 명시적으로도 바인딩할 수 있는 방법을 제공한다. 이를 통해 this가 소실되는 문제를 해결할 수 있다. 

함수 객체는 call, apply, bind 등의 메서드를 통해서 명시적으로 this를 바인딩할 수 있는 방법을 제공한다. 

call과 apply를 사용하면 this를 바인딩할 객체를 지정한 상태로 함수를 호출할 수 있다.

```jsx
call(context, arg1, arg2,...)
apply(context, args)
```

첫 번째 인자로 this를 바인딩 할 객체를 전달하고 그 다음에 인수를 넣어준다. call과 apply 메서드는 사실 하는 역할이 거의 유사하지만 뒤에 인수를 전달하는 방식만 차이가 있다. call 같은 경우에는 인수를 하나하나 전달하는 방식이고 apply는 이런 인수들을 배열형태나 유사배열 형태로 전달해준다. 

```jsx
func.bind(context, arg1, arg2, ...)
```

bind 메서드는 this가 참조하는 객체를 고정시켜준다.

마찬가지로 첫 번째 인자의 this를 바인딩할 객체를 넣어주고 이후에는 인수로 사용될 값들을 넣어준다. 이 메서드가 반환하는 특수한 객체가 하나 있는데 그 객체는 마치 항상 this가 어떤 특성 객체에 바인딩되어 있는 함수처럼 행동을 한다.

이렇게 항상 같은 객체에 바인딩 되도록 강제 하는 방법을 **하드 바인딩**이라고도 부른다.

## new 바인딩

```jsx
new func() -> 
1. 새로운 객체 형성
2. 함수 코드 실행
3. 새로 생성한 객체 반환
```

자바스크립트 함수를 또 다른 방식으로 호출 할 수도 있다. 바로 new 연산자를 이용한 호출이다.

자바스크립트 함수를 new연산자와 함께 호출 하게 되면 생성자함수로서의 역할을 수행할 수 있게 된다. 

먼저 new 연산자로 호출하면 새로운 객체를 하나 그 안에서 만든다. 그리고 함수의 코드를 실행하고 새로 생성한 객체를 반환해준다. 

```jsx
{
  obj = {} // create new object
  this = obj // bind
  
  this.name = 'youjung' // obj : { name : 'youjung' }

  return this
}
```

그리고 이 과정에서 this는 새로 생성한 객체에 바인딩 된다. 이 과정을 pseudo code로 간단하게 표현하면 이런 모양이 된다.

이런 과정을 통해 프로퍼티가 정해진 객체를 반환하는 생성자의 역할을 수행할 수 있게 된다.

이렇게 new 연산자로 함수를 호출할 때 this가 바인딩되는 규칙을 **new binding**이라고 한다.

<aside>
↗️ 기본 바인딩 < 암시적 바인딩 < 명시적 바인딩  < new 바인딩

</aside>

함수가 매번 네가지 케이스 중 하나만 해당하면 좋을 텐데 코딩을 하다 보면 중복으로 해당되는 경우가 있을 수 있다. 이 경우에는 this가 우선순위에 따라 바인딩된다. 그리고 어떠한 것에도 해당되지 않을 때에는 전역 객체나 undefined값을 가지게 된다. 

## 화살표 함수

ES6 부터 화살표함수라는 함수가 추가되었다. 화살표 함수는 다른 함수들이랑 this를 바인딩 하는 방법이 다르다. 사실 this만 다른게 아니라 여러 부분에 있어 일반 함수랑 다른 모습을 보인다.

```jsx
const obj = {
  name: 'youjung'
  showNameInSec(sec) {
    setTimeout(()=>{
      console.log(this.name);
  }, sec);
  },
};

obj.showNameInSec(1000); // youjung
```

예제를 보면 showNameInSec안에서 setTimeOut 함수에 콜백으로 화살표 함수를 전달하고 있다. 만약 이 화살표 함수가 다른 일반 함수처럼 바인딩 했으면 문제가 생겼을 것이다. 왜냐하면 callback으로 넘겨 버리면 this가 너무 의미를 잃어버린 상황이기 때문이다. 

그런데 자바스크립트는 정상적으로 1초 뒤에 youjung이라는 문자열을 보여주게 된다.

화살표함수는 일반함수와 많은 차이점을 가지고 있고 그만큼 사용목적도 다르다. 
화살표 함수를 사용하는 가장 큰 목적 중 하나는 **상위 실행 문맥을 유지**하는 것이다.

렉시컬 스코프와 관계없이 호출 당시에 의존하는 기존의 binding 규칙은 화살표함수 안에서 this에 전혀 의미가 없다. 
화살표 함수 안에서 this는 선언될 당시에 상위 실행 문맥(상위 스코프)  그 스코프에 해당하는 실행 문맥 상의 this 바인딩 컴포넌트를 참조한다. 
쉽게 말해 상위 스코프의 this를 가르킨다고 보면 된다.

따라서 이 코드 안에서는 화살표 함수 안에 있는 this가 showNameInSec 함수 실행 문맥에 있는 this와 같은 것이다.

이런 this의 동작하는 모습을 보고 있으면 마치 외부 렉시컬 환경, 그러니까 상위 스코프의 변수를 참조하는 모습과 비슷하다. 이런 특징을 갖는 this를 **어휘적 this, 혹은 렉시컬 this**라고 부른다.
