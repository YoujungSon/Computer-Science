# 가상 메모리(Virtual Memory)

- 스와핑, 외부 단편화, 내부 단편화, 페이징, 세그멘테이션

# 1️⃣ 연속 메모리 할당

- 연속 메모리 할당: 프로세스에 연속적인 메모리 공간을 할당하는 방식

<img src="https://images.velog.io/images/lcy960729/post/bf508040-e8b2-4ca3-ab48-6a19ec4e13c4/image.png" width=600>

## ✔ 스와핑

- 스와핑 : 메모리에 적재된 프로세스들 중에 오랫동안 사용되지 않은 프로세스는 보조기억 장치로 보내고, 실행할 프로세스를 메모리로 옮기는 메모리 관리 기법
- 스왑 영역 : 보조기억 장치의 일부 영역으로 스왑 아웃된 프로세스들이 있는 곳
- 스왑 아웃 : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- 스왑 인 : 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것

<img src="https://lh4.googleusercontent.com/ISx3q1vjwytuAyehzREYzLqKytn-KLqEb4Dw5kW0yNIKfECTUpETXAWfUp5FHGvbyx6SnO8MD7ysSJYnlY9LjppFm0elS3dQbk7LDLmJEICK_-J61ZX4su6DaozFxBY4wx-k9Q4PkKsLLIFewr4PJ8s" width=500>

스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리보다 큰 경우에도 프로세스들을 동시 실행할 수 있다


<br>

## ✔ 외부 단편화(external fragmentation)

- 외부 단편화 : 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상
- 프로세스를 메모리에 연속적으로 배치하는 연속 메모리 할당은 외부 단편화 문제를 내포하고 있기 때문에 메모리를 효율적으로 사용하는 방법이 아님

<img src="https://blog.kakaocdn.net/dn/A2ebn/btrnv29ql8l/bUHpFVuDT0hLGJTgLWeDqk/img.png" >

### 🔍 외부 단편화 해결 방안

1. 메모리 압축(메모리 조각 모음)
   - 여기저기 흩어져있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 적당히 재배치 시켜 여기저기 흩어져있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법
   - 이 작업을 진행하는 동안 시스템은 하던 일을 중지해야 하고, 메모리에 있는 내용을 옮기는 작업은 많은 오버 헤드를 야기한다.
2. 가상메모리 기법 - 페이징

# 2️⃣ 가상 메모리 기법 - 페이징(paging)과 세그멘테이션(segmentation)

- 연속 메모리 할당의 문제점은 외부 단편화와 물리 메모리보다 큰 프로세스를 실행할 수 없다는 점이다
- 가상 메모리(virtual memory) : 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
- 가상 메모리 기법에는 페이징과 세그멘테이션이 있음
- 현대 대부분의 운영체제는 페이징 기법을 사용한다

## ✔ 페이징(paging)

- 프로세스를 **일정한 크기**의 페이지로 분할해서 메모리에 적재하는 방식
- 페이지 : 고정 사이즈의 가상 메모리 내 프로세스 조각
- 프레임 : 페이지 크기과 같은 주 기억 장치의 메모리 조각

- 페이지 단위로 스왑 아웃/ 스왑 인 된다. (페이지 아웃/페이지 인 이라고도 함)
- 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없기때문에 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있고, 이를 통해 물리 메모리보다 더 큰 프로세스를 실행할 수 있음

## ✔ 페이징 테이블(paging table)

- 프로세스를 이루는 페이지가 어느 프레임에 할당되어있는지 알려주는 일종의 이정표
- 물리 주소 상에서는 프로세스들이 분산되어 저장되어 있더라도 CPU 입장에서 바라본 논리 주소는 연속적으로 보일 수 있다

 <img src="https://user-images.githubusercontent.com/37871541/78530736-2c410780-781f-11ea-8186-50e4a90a2691.png" width="600s">

- 프로세스마다 각자의 페이지 테이블을 가지고 있고, 각 프로세스의 페이지 테이블은 메모리에 적재되어 있음
- CPU 내의 페이지 테이블 베이스 레지스터(PTBR, Page Table Based Register)는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있음

<img src="https://user-images.githubusercontent.com/89509857/210052062-8a30a116-380c-43a6-8b0d-714aba172b56.png" width=700>

## ✔ TLB(Translation Lookside Buffer)

- 페이지 테이블을 메모리에 두면 메모리 접근 시간이 두 배로 늘어난다.
- 메모리에 있는 페이지 테이블에 한 번, 그 후에 프레임에 접근하기 위해 한 번, 총 두 번의 접근이 필요하기 때문이다.
- 이러한 문제를 해결하기 위해 CPU 옆에 TLB라는 페이지 테이블 캐시 메모리를 둔다
- TLB 히트 : CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우
- TLB 미스 : 페이지 번호가 TLB에 없을 경우

## ✔ 페이징에서의 주소 변환

- 하나의 페이지 혹은 프레임은 여러 주소를 포괄하고 있기 때문에 '어떤 페이지 혹은 프레임에 접근하고 싶은지', 그리고 '접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져있는지'를 알아야 한다.

=> 페이징 시스템에서는 모든 논리 주소가 기본적으로 **페이지번호**와 **변위**로 이루어져 있다.

- 페이지 번호 : 말 그대로 접근하고자 하는 페이지 번호
- 변위 : 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져있는지 알기 위한 정보

<img src="https://user-images.githubusercontent.com/89509857/210052069-d32f6b1a-31cb-4dc5-a9cd-644a1c3ef7a3.png" width=700>

Q. 논리 주소 <5,2> ?
A. 10번지

## ✔ 페이징의 이점 - 쓰기 시 복사(copy on write)

- 외부 단편화 문제를 해결한다는 점 외에도 페이징이 제공하는 이점들이 있는데 그 중 하나가 프로세스 간에 페이지를 공유할 수 있다는 점이다.

- 프로세스를 fork 하여 동일한 프로세스 두 개가 복제되면 코드 및 데이터 영역을 비롯한 모든 자원이 복제되어 메모리에 적재된다.
- 이 복사 작업은 프로세스 생성 시간을 늦출 뿐만 아니라 불필요한 메모리 낭비를 야기한다
- 쓰기 시 복사에서는 부모 프로세스와 동일한 자식 프로세스가 생성되면 자식 프로세스는 부모 프로세스와 동일한 프레임을 가리킨다.
- 부모 프로세스의 메모리 공간을 복사하지 않고도 동일한 코드 및 데이터 영역을 가리키는 것.
- 이것이 쓰기 시 복사의 개념!
- 읽기 작업만 할 때는 이 상태가 지속되다가 부모 프로세스와 자식 프로세스 둘 중 하나가 쓰기 작업을 하면 그 순간 해당 페이지가 별도의 공간으로 복제된다.
- 프로세스 생성 시간을 줄이는 것은 물론 메모리 공간 절약도 가능하다.

  <img src="https://images.velog.io/images/thdalstn6352/post/94c3ec03-a606-4a8f-8570-953b8936a478/image.png">

  <img src="https://images.velog.io/images/thdalstn6352/post/215a2335-f80e-49e3-bda0-65479e0fbfbe/image.png">

## ✔ 내부 단편화

- 페이징은 외부 단편화 문제를 해결할 수 있지만, 내부 단편화 문제를 야기할 수 있다.
- 모든 프로세스의 크기가 페이지의 배수가 아니기 때문에, 내부 단편화가 발생한다.

<img src="https://mblogthumb-phinf.pstatic.net/20160211_133/rbdi3222_1455175332182MjpUA_JPEG/%B3%BB%BA%CE.JPG?type=w2" width=600>

- 즉, 내부 단편화는 하나의 페이지보다 작은 크기로 발생한다.
- 하나의 페이지 크기가 작다면 발생하는 내부 단편화의 크기가 작아질 것으로 기대할 수도 있지만, 하나의 페이지 크기를 너무 작게 설정하면 그만큼 페이지 테이블의 크기도 커지기 때문에 페이지 테이블이 차지하는 공간이 낭비된다.

## ✔ 세그멘테이션(segmetation)

: 세그멘테이션은 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치하는 것을 의미

- 따라서 나눠진 크기는 일정하지 않다
- 세그멘테이션에서는 프로세스를 세그먼트의 집합으로 생각한다.
- 세그먼트 (segment) : main program, function, method, object, stack, local variable, global variable, etc

## ✔ 세그먼트 테이블

: 페이징 테이블과 비슷하게 '세그먼트 번호(segment-number)'와 '변위(offset)'이루어져 있지만, 세그먼트의 크기가 일정하지 않기 때문에 limit 정보다 추가로 있다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fol2eM%2FbtrnC38FGmG%2FKv5nbXQG2rCUeck0pRS8I0%2Fimg.png" width="700">

Q. 논리주소 <2, 100>
A. 4400

Q. 논리주소 <1, 500>
A. 범위를 벗어나 인터럽트

## ✔ 단점

- 세그멘테이션에서는 세그먼트의 크기가 일정하지 않고 다양하기 때문에 외부단편화가 발생하여 메모리 낭비가 크게 된다.
- 따라서 현재 대부분은 페이징 기법을 많이 사용한다.
