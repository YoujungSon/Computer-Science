# 프로세스 동기화(Process Synchronization)

동시다발적으로 실행되는 프로세스들은 공동의 목적을 올바르게 수행하기 위해 서로 협력하며 영향을 주고받는다. 실행되는 프로세스들은 **실행 순서**와 **자원의 일관성**을 보장해야 하기 때문에 반드시 **동기화** 되어야 한다.

## 1️⃣ 프로세스 동기화란?

프로세스들 사이의 수행 시기를 맞추는 것을 의미

- 실행 순서 제어 : 프로세스를 올바른 순서대로 실행하기
- 상호 배제 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기

💡 실행흐름을 갖는 모든 것은 동기화의 대상이므로 스레드도 동기화의 대상이다

### ✔ 실행 순서 제어를 위한 동기화 예시

- Writer 프로세스 : Book.txt 파일에 값을 저장하는 프로세스
- Reader 프로세스 : Book.txt 파일에 저장된 값을 읽어 들이는 프로세스
- Writer 프로세스가 Book.txt에 값을 저장하기도 전에 Reader 프로세스가 Book.txt를 읽는 것은 올바른 순서가 아님
- Reader 프로세스는 Book.txt 안에 값이 존재한다는 특정 조건이 만족되어야만 실행을 이어나갈 수 있어야 함

### ✔ 상호 배제를 위한 동기화 예시

💡 상호 배제 : 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘

프로세스 A

1. 계좌의 잔액을 읽어들이기
2. 읽어 들인 잔액에 2만원을 더하기
3. 더한 값을 저장하기

프로세스 B

1. 계좌의 잔액을 읽어들이기
2. 읽어 들인 잔액에 5만원을 더하기
3. 더한 값을 저장하기

=> 프로세스 A와 B가 동시에 실행되었다면, 그 결과는?

**동기화가 이루어지지 않은 경우**

<img src="https://user-images.githubusercontent.com/89509857/209267538-e1a4d982-c0fb-41f6-9c17-8f57a89df0ee.png" width="700">

**동기화가 이루어진 경우**

<img src="https://user-images.githubusercontent.com/89509857/209267553-95c8be61-7725-455a-b209-d69ce5948656.png" width="700">

## 2️⃣ 공유 자원과 임계 구역

- 공유 자원 : 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 의미
- 임계 구역(critical section) : 공유 자원 중에 두 개 이상의 프로세스를 동시에 실행하면 문제가 발생하는 자원. 공유 데이터의 일관성을 보장하기 위해 하나의 프로세스만 진입해서 실행가능한 영역. 두 개 이상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 하나는 대기하고, 먼저 진입한 프로세스의 작업이 마무리 되면 대기 중이던 프로세스가 임계 구역에 진입한다
- 레이스 컨디션 : 두 개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황
- 레이스 컨디션이 발생하면 데이터의 일관성이 깨지는 문제가 발생한다.
- 상호 배제를 위한 동기화는 이와 같은 일이 발생하지 않도록 두 개 이상의 프로세스가 임계 구역에 접근하지 못하도록 관리하는 것

### 상호 배제를 위한 동기화 원칙

1. 상호 배제 : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다
2. 진행 : 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
3. 유한 대기 : 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다. (임계 구역에 들어오기 위해 무한정 대기해서는 안된다. )

<br>

# 동기화 기법

스핀락, 뮤텍스, 세마포

## 1️⃣ 스핀락

: 동시에 접근해서는 안되는 자원에 동시에 접근하지 않도록 만드는 도구. 즉, 상호 배제를 위한 동기화 도구

- Locking 메커니즘으로 임계 구역에 자물쇠를 걸어두는 방식
- 임계 구역에 진입하는 프로세스는 락을 걸고, 다른 프로세스가 임계구역에 접근할 때 락이 걸려있다면 기다리고, 락이 걸려있지 않다면 임계 구역에 진입한다.

### ✔ 구현

- 자물쇠 역할 : 프로세스들이 공유하는 전역변수 lock
- 임계 구역을 잠그는 역할 : acquire 함수
- 임계 구역의 잠금을 해제하는 역할 : release 함수

### 🔍 acquire 함수

: 프로세스가 임계 구역에 진입하기 전에 호출하는 함수

- 임계 구역이 잠겨있다면 (lock이 true라면), 열릴 때까지(lock이 false가 될 때까지) 임계 구역을 반복적으로 확인하고
- 임계구역이 열려있다면 임계 구역을 잠그는(lock을 true로 바꾸는) 함수

```
acquire() {
  while(lock == true) {  /* 만약 임계 구역이 잠겨있다면 */
    check();           /* 임계 구역이 잠겨 있는지를 반복적으로 확인 */
  }
  lock = true;         /* 만약 임계 구역이 잠겨 있지 않다면 임계 구역 잠금 */
}
```

### 🔍 release 함수

: 임계 구역에서 작업이 끝나고 호출하는 함수로 현재 잠긴 임계 구역을 열어주는 (lock을 false로 바꾸는)함수

```
release() {
  lock = false;  /* 임계 구역 작업이 끝났으니 잠금 해제 */
}
```

### 🔍 프로세스가 임계 구역에 진입하는 방법

```
acquire();        /* 잠겨있는지 확인, 잠겨 있지 않다면 잠그고 들어가기*/
// 임계 구역 진입  /* 임계 구역에서 작업 진행 */
release();        /* 잠금 해제 */
```

### 💡 바쁜 대기(busy waiting)

: 어떤 특정한 임계 영역에 접근이 가능한지 무한으로 검사하고 있는 현상
=> 스핀락의 acquire 함수를 보면 임계 구역이 잠겨있을 경우 프로세스는 반복적으로 lock을 확인하고 있으므로 바쁜 대기를 하고 있음.. => **CPU 를 계속 낭비**

```
acquire() {
  while(lock == true){  /* 만약 임계 구역이 잠겨있다면 */
    check();           /* 임계 구역이 잠겨있는지를 반복적으로 확인 */
  }
}
```

## 2️⃣ 뮤텍스(Mutex)

: 락을 가질 수 있을 때까지 '휴식'을 하는 방식의 동기화 도구

### ✔ 대기 큐

- 스핀락에서는 사용할 수 있는 공유 자원이 없는 경우 프로세스는 계속해서 확인하는 바쁜 대기를 반복한다.
- 바쁜 대기는 CPU는 더 생산성 있는 작업을 할 수 있는데, CPU 주기를 낭비한다는 점에서 손해이다.
- 뮤텍스는 자원이 없을 경우 해당 프로세스 상태를 대기 상태로 만들고 그 프로세스의 PCB를 대기 큐에 집어 넣는다.
- 다른 프로세스가 signal 함수를 호출하면 signal 함수는 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮긴다.

### ✔ 구현

- value : 임계 구역에 접근할 수 있는지를 나타내는 전역변수
- lcok() : 임계 구역을 잠그는 역할
- unlock() : 임계 구역의 잠금을 해제하는 역할

```
value = 1; /* 임계 구역에 접근할 수 있는 상태 */

lock() {
  if(value == 0) {                /* 다른 프로세스가 임계 구역에 이미 있는 상태 */
    add this process to Queue;    /* 해당 프로세스 PCB를 대기 큐에 삽입 */
    sleep()                       /* 대기 상태로 접어듦 */
  } else {
    value = 0;                    /* 임계 구역을 사용할 수 없게 잠금 */
  }
}

unlock() {
  if(큐에 하나라도 대기중이라면) {
    wakeup(p)                   /* 프로세스를 깨운다 */
  } else {
    value = 1;                  /* 임계 구역을 사용할 수 있게 잠금을 품 */
  }
}

```

### 뮤텍스가 스핀락보다 훨씬 좋은 걸까?

- 멀티 코어 환경이고, 임계 구역에서의 작업이 문맥교환보다 더 빨리 끝난다면 스핀락이 뮤텍스보다 더 이점이 있음
  - 뮤텍스의 잠들고 깨는 과정에서 문맥교환이 발생한다.
    싱글 코어에서는 누군가가 쥐고있는 락을 어쨌든 풀어주기 위해서 문맥교환이 발생하기 때문에 스핀락의 이점이 없다.
  - 멀티코어에서는 cpu에 코어가 두 개가 있기 때문에 문맥교환이 발생하지 않을 수 있다. (락을 해제하는 cpu 코어와 락을 확인하는 코어가 다르기 때문에 문맥교환이 발생하지 않는다.)

## 3️⃣ 세마포어(Semaphore)

: 공유 자원이 **여러 개** 있을 경우 여러 개의 프로세스가 각각 공유 자원에 접근이 가능하여야 하는데, 이런 때에도 적용이 가능한 동기화 도구

- 프로세스는 임계 구역 앞에서 멈춤 신호를 받으면 기다리고,
- 들어가도 좋다는 신호를 받으면 임계 구역에 들어간다

### ✔ 구현

- 전역 변수 S : 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 변수
- wait 함수 : 임계 구역에 들어가기 전에 수행하는 함수로 임계 구역에 들어가도 되는지, 기다려야 하는지 알려주는 함수
- signal 함수 : 임계 구역에서 나올 때 수행하는 함수로 자원을 반납하며, 대기 중인 프로세스를 깨우는 신호 함수

```
wait()
// 임계 구역
signal()
```

```
S = 1                             /* 사용 가능한 공유 자원의 개수 */

wait() {
  if(S == 0) {
    add this process to Queue;    /* 해당 프로세스 PCB를 대기 큐에 삽입 */
    sleep()                       /* 대기 상태로 접어듦 */
  } else {
    S--;                          /* S를 1 감소 시키고 임계 구역에 진입한다 */
  }
}
```

```
signal() {
  if(큐에 하나라도 대기중이면) {
    remove a process from Queue   /* 대기 큐에 있는 프로세스 p를 제거 */
    wakeup(p)                     /* 프로세스 p를 대기 상태에서 준비 상태로 만듦 */
  } else {
    S++                           /* 임계 구역에서의 작업을 마친 뒤 S를 1 증가시킨다 */
  }
}
```

### 🔍 실행 순서 제어를 위한 동기화

- 동기화는 상호배제를 위한 동기화와 실행 순서 제어를 위한 동기화가 있다
- 지금까지는 상호배제를 위한 동기화만을 봤다면,
- 세마포는 실행 순서 제어를 위한 동기화에도 사용 가능하다

#### 방법

```
S = 0               /* S를 0으로 지정 */
task1 => signal()   /* 먼저 실행할 프로세스 뒤에 signal 함수 */
wait() => task2     /* 나중에 실행할 프로세스 앞에 wait 함수 */
```

- 이 경우 task2는 무조건 task1보다 나중에 실행된다.
- 만약 task1이 먼저 자원에 접근한 경우, task1이 실행되고, task1의 작업이 끝난 뒤에, 그 뒤에 task2가 실행된다.
- 만약 task2가 먼저 자원에 접근한 경우, wait() 실행, 대기상태에 접어들고, task1이 먼저 실행된다.

### ✔ 뮤텍스 vs 세마포

- 세마포어에는 binary(이진)세마포어와 counting 세마포어가 있다
- S(공유 자원)의 개수가 1인 경우를 binary 세마포어, 그 이상인 경우 counting 세마포어라고 한다.

#### 🔍 차이점

- 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없습니다.
- 뮤텍스는 락을 가진 프로세스만 락을 해제할 수 있지만, 세마포어는 다른 프로세스가 해제할 수 있다
- 뮤텍스의 경우 lock의 상태가 두개뿐이므로 lock을 소유할 수 있지만, 세마포어는 불가능하다
