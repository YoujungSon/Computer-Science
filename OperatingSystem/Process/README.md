# 프로세스(Process)

- 프로세스의 개념
- 일괄 작업 방식 vs 시분할 방식
- 프로그램에서 프로세스로의 전환
- 프로세스의 상태
- 프로세스 제어 블록
- 문맥 교환
- 프로세스의 연산
- 스레드(Thread)

# 1️⃣ 프로세스의 개념

- 운영체제에서 프로세스는 하나의 작업 단위이다.
- 사용자가 마우스를 더블클릭 하여 프로그램을 실행하면 그 프로그램은 프로세스가 된다.
- 프로그램과 프로세스의 차이는?
- 폰노이만 구조 : "모든 프로그램은 메모리에 올라와야 실행할 수 있다."
  - 폰노이만 구조 : CPU, 메모리, 입출력장치, 저장장치가 버스로 연결되어 있는 구조로 오늘날의 컴퓨터는 대부분 폰노이만 구조를 따른다
- 프로그램은 저장장치에 저장되어 있는 정적인 상태, 프로세스는 실행을 위해 메모리에 올라온 동적인 상태

# 2️⃣ 일괄 작업 방식 vs 시분할 방식

## ✅ 일괄 작업 방식

- 한 번에 한 가지 작업만 가능한 방식.
- 하나의 작업을 읽어들여 실행하고, 결과를 출력한 후에 다음 작업을 읽어들여 실행하는 방식이다.
- 모든 작업을 한꺼번에 처리해야 하고, 프로그램 실행 중간에 사용자가 데이터를 입력하거나 수정하는 것이 불가능하다. => 일괄 작업 시스템(batch job system), 일괄 처리 시스템(batch processing system)

## ✅ 시분할 방식

- 현대의 운영체제는 시분할 방식을 기본으로 사용한다.
- 오늘날의 컴퓨터에도 대부분 시분할 시스템이 사용된다.
- 다중 프로그래밍, 하나의 CPU 로 여러 작업을 동시에 실행하는 기술로 효율성이 뛰어나다.
- 그런데 여러 작업이 하나의 CPU를 공동으로 사용하면 작업이 끊겨 보일 텐데 다중 프로그래밍 시스템에서는 여러 작업이 동시에 실행되는 것처럼 보인다. 어떻게 가능한 걸까?
- 시간을 분할하는 방법 때문이다!
- 다중 프로그래밍 시스템에서는 CPU 사용 시간을 아주 잘게 쪼개어 여러 작업에 나누어준다.
- 예를 들어, 각 작업에 1초씩 할당하면 작업이 끊어지면서 실행되겠지만, 0.1초씩 할당한다면 A 작업에 0.1초, B 작업에 0.1초, C작업에 0.1초를 돌아가며 배정하여 A 작업은 0.3초 뒤에 다시 CPU를 얻어 작업할 수 있다. 이렇게 시간분배가 매우 빠른 속도로 반복되면 A, B, C가 동시에 실행되는 것처럼 보인다.
- 이때 잘게 나눈 시간 한 조각을 타임 슬라이스(time slice) 또는 타임 퀀텀(time quantum)이라고 한다.

# 3️⃣ 프로그램에서 프로세스로의 전환

- 프로세스는 컴퓨터 시스템의 작업 단위로 태스크(task)라고도 부른다.
- 우선 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다.
- 그와 동시에 프로세스 제어 블록(PCB, process control block)을 만든다.
  - 프로세스를 처리하는 데 필요한 다양한 정보가 들어있고, 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 못한다. 어떤 프로그램이 프로세스가 되었다는 뜻은 운영체제로부터 프로세스 제어 블록을 받았다는 의미이다.
- 프로세스 제어 블록은 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에, 운영체제 영역에 만들어 진다.
- 프로세스가 종료되면 프로세스가 메모리에서 삭제되고 프로세스 제어 블록도 폐기된다.
  <img src="https://user-images.githubusercontent.com/89509857/203506702-cc064b1d-94f1-4f4f-8ed8-c46b6be29b44.png" width="700">
- 잊지 말아야 할 점은, 운영체제도 프로그램이기 때문에 프로세스 형태로 실행되어야 한다는 사실이다.
  - 컴퓨터를 켰을 때 운영체제를 메모리에 올리는 과정을 부팅(booting)이라고 한다.
  - 부트스트랩(bootstrap): 운영체제를 메모리로 가져와 실행하는 역할을 하는 작은 프로그램

### 프로세스와 프로그램의 관계

프로세스 = 프로그램 + 프로세스 제어 블록
<br/>
프로그램 = 프로세스 - 프로세스 제어 블록

# 4️⃣ 프로세스의 상태

운영체제에서도 여러 가지 이유로 프로세스의 상태(process status)가 변화한다.

- 일괄 작업 시스템에서 프로세스 상태는 생성(crate), 실행(run), 완료(terminate) 이다.
- 시분할 시스템에서의 프로세스 상태는 일괄 작업 시스템보다 복잡하다. CPU를 얻어 실행 중인 프로세스가 중간에 다른 프로세스에 CPU를 넘겨주는 일이 빈번하기 때문이다.

## 프로세스의 네 가지 상태

<img src="https://user-images.githubusercontent.com/89509857/203509974-4e386f64-f292-4ed3-892d-8b75555cca8f.png" width="700">

- **생성 상태(create status)** : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태, 프로세스를 관리하는 데 필요한 프로세스 제어 블록이 생성된다.
- **준비 상태(ready status)** : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태. CPU가 하나인 컴퓨터에서는 한 번에 하나의 프로세스만 실행할 수 있기 때문에 자기 실행 순서가 될 때까지 준비 상태에서 기다려야한다.
- **실행 상태(running stauts)** : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태로 execute status라고 표현하기도 한다. 실행 상태에 들어간 프로세스는 일정 시간 동안 CPU를 사용할 권리를 갖는다. 만약 주어진 시간을 다 사용하고도 작업이 끝나지 않았다면(time out) 프로세스는 준비 상태로 돌아와 다음 차례를 기다린다. 프로세스는 자신의 작업이 끝날 때까지 준비 상태와 실행 상태를 왔다갔다 한다.
- **완료 상태(termintae status)** : 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입한다. 완료 상태는 프로세스 제어 블록이 사라진 상태를 의미한다.
- 준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 CPU 스케쥴러(CPU scheduler)가 담당한다.
- CPU 스케쥴러는 전 상태, 즉 생성, 준비, 실행, 완료에 관여하여 모든 프로세스의 작업이 원만하게 이루어지도록 관리한다.

## 프로세스의 다섯 가지 상태

프로세스는 생성, 준비, 실행, 완료라는 네 가지 상태만으로 작업을 진행하는 데 큰 문제가 없다. 그러나 오늘날 운영체제의 효율성을 고려하여 한 가지 상태를 더 만들었다.

- 어떤 프로세스가 실행 상태에 들어가 입출력을 요구했다고 가정해보자.
- 이때 CPU가 직접 데이터를 가져오지 않고 입출력 관리자에게 명령을 내린다. 이 상태에서 프로세스는 요청한 작업이 끝날 때까지 다음 작업을 할 수 없어 효율성이 떨어진다.
  => 대기 상태
- 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태를 '대기 상태(blocking status)라고 한다.

<img src="https://user-images.githubusercontent.com/89509857/203510087-e3ef6514-2456-4266-994f-5c0049da723f.png" width="700">

- 입출력을 요청한 프로세스가 대기 상태로 옮겨지면 CPU 스케쥴러는 준비 상태에 있는 프로세스 중 하나를 가져다 실행 상태로 만든다. 그러면 시스템 입장에서는 새로운 작업을 진행하게 되어 효율성이 높아진다.
- 대기 상태의 프로세스는 입출력이 완료되면 실행상태로 돌아가는 것이 맞지만, 그러려면 현재 실행 상태에서 작업 중인 프로세스를 준비 상태로 돌려야 하고, 두 프로세스의 상태를 변화시키는 건 복잡한 상황이므로 대기 상태에서 입출력이 끝난 프로세스는 실행 상태로 가지 않고 준비 상태로 돌아가 자기 차례를 기다린다.

## 휴식 상태와 보류 상태

대부분의 프로세스는 생성, 준비, 실행, 대기, 완료 상태로 운영되며 이 다섯 가지 상태를 활성 상태(active status)라고 한다. 그리고 활성 상태 외에 또 다른 상태가 있다.

### ✅ 휴식 상태

- 휴식 상태는 프로세스가 작업을 일시적으로 쉬고 있는 상태
- 유닉스에서 `ctrl + z` 키를 눌러 휴식 상태로 들어갈 수 있다.
- 사용하던 데이터가 메모리에 그대로 있고, 프로세스 제어 블록도 유지되므로 프로세스는 멈춘 지점에서부터 재시작(resume) 할 수 있다.

  <img src="https://user-images.githubusercontent.com/89509857/203657716-c4eb8a3f-e3dd-4c3f-8247-f2985e80e666.png" width=600>

  - jobs : 상태 확인, bg: background로 실행

- 프로세스의 상태가 정지 임을 알 수 있다. 정지는 휴식 상태의 예이다.
- 유닉스에서 `ctrl+c`를 누르면 프로그램을 강제 종료 할 수 있다. 이때는 메모리에서 사라지고 프로세스 제어 블록도 사라지기 때문에 사용하던 데이터를 잃어버리고, 처음부터 다시 시작해야한다.

### ✅ 보류 상태

- 보류 상태는 프로세스가 메모리에서 잠시 쫓겨난 상태로, 휴식 상태와 차이가 있다.
- 보류 상태를 '일시 정지 상태'라고도 불리며, 보류 상태와 비교하여 일반적인 프로세스 상태를 활성상태라고 한다.

```
다음과 같은 경우에 보류 상태가 된다.
- 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때.
- 프로그램에 오류가 있어서 실행을 미루어야 할 때
- 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
- 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
- 입출력을 기다리는 프로세스의 입출력이 계속 지연될 떄
```

<img src="https://user-images.githubusercontent.com/89509857/203510102-a849f56b-df24-45c3-a960-40a46a97c204.png" width=700>

- 보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑영역(swap area)에 보관된다
  - 스왑 영역은 메모리에서 쫓겨난 데이터가 임시로 보관되는 장소
- 보류 상태는 대기 상태에서 옮겨진 '보류 대기 상태' 와 준비 상태에서 옮겨진 '보류 준비 상태'로 구분된다.
- 재시작 하면 원래의 활성 상태로 돌아간다.
- 보류 대기 상태에서 입출력이 완료되면 활성상태가 아닌 보류 준비 상태로 옮겨진다.

# 5️⃣ 프로세스 제어 블록(PCB, Process Control Block)

-프로세스 제어 블록은 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료구조

- TCB(Task Control Block)이라고도 부른다.

## 프로세스 제어 블록의 구성

1. 포인터 : PCB의 첫 번째 블록에는 포인터가 저장된다. 준비 상태나 대기 상태는 큐로 운영되는데, 큐를 구현할 때 포인터를 사용한다.
2. 프로세스 상태 : PCB 두 번째 블록에는 프로세스 상태가 저장된다. 프로세스가 현재 어떤 상태에 있는지 나타낸다.
3. 프로세스 구분자 : PID(Process ID), 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자
4. 프로그램 카운터 : 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값을 저장
5. 프로세스 우선 순위 : 프로세스의 중요도가 각각 다르고, 사용자 프로세스보다 커널 프로세스가 우선순위가 더 높고, 사용자 프로세스끼리도 우선순위가 다르다. 따라서 대기 상태의 큐도 우선순위 별로 따로 운영된다.
6. 각종 레지스터 정보 : 프로세스가 실행되는 중에 사용하던 레지스터 값이 저장된다.
7. 메모리 관리 정보 : 프로세스가 메모리의 어디에 있는지 나타내는 메모리 위치 정보, 경계 레지스터 값과 한계 레지스터 값 등이 저장된다. 그 외 세그멘테이션 테이블, 페이지 테이블 등의 정보도 보관한다.
8. 할당된 자원 정보 : 프로세스를 실행하기 위해 사용되는 입출력 자원이나 오픈 파일 등에 대한 정보를 말한다.
9. 계정 정보 : 계정 번호, CPU 할당 시간, CPU 사용 시간 등
10. 부모 프로세스 구분자와 자식 프로세스 구분자 : 부모 프로세스를 가리키는 PPID(Parent PID) 와 자식 프로세스를 가리키는 CPID(Child PID)정보가 저장된다.

# 6️⃣ 문맥 교환

- 문맥 교환은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다.
- 실행 상태에서 나가는 프로세스 제어 블록에는 지금까지의 작업 내용을 저장하고, 실행 상태로 들어오는 프로세스 제어 블록의 내용으로 CPU가 다시 세팅된다.

<img src="https://user-images.githubusercontent.com/89509857/203663297-45cc12e6-a2be-4e79-bb02-e39b935450b8.png" width=600>

문맥 교환이 일어나는 경우

```
- 한 프로세스가 자신에게 주어진 시간을 다 사용했을 때
- 인터럽트가 걸렸을 때
```

# 7️⃣ 프로세스의 연산

프로세스는 어떻게 생성되고 복사되는지 알아볼 것인데, 그 전에 프로세스의 구조부터 알아보자.

## 1. 프로세스의 구조(메모리 구조)

- 프로세스는 코드 영역, 데이터(일반 데이터 영역과 힙 영역)영역, 스택 영역으로 구성
- 예를 들어 워드프로세스 프로그램을 실행하면 이 프로그램 코드는 코드 영역에 탑재되고, 워드프레서로 편집 중인 문서는 데이터 영역에, 운영체제가 워드프로세서를 작동하기 위해 사용하는 각종 부가 데이터는 스택 영역에 쌓인다.
- **코드 영역** : 프로그램의 본문이 기술된 곳으로 텍스트 영역이라고도 한다. 프로그래머가 작성한 프로그램은 코드 영역에 탑재되며 탑재된 코드는 읽기 전용으로 처리된다. 자기 자신을 수정하는 프로그램은 존재하지 않기 때문이다.
- **데이터 영역** : 코드가 실행되면서 사용하는 변수, 파일 등의 각종 데이터를 모아놓은 곳. 읽기와 쓰기가 가능하다.
- **스택영역** : 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳. 예를 들어 프로세스 내에서 함수를 호출하면, 함수를 수행하고 원래 프로그램으로 되돌아올 위치를 이 영역에 저장한다. 스택 영역은 운영체제가 사용자의 프로세스를 작동하기 위해 유지하는 영역이므로 사용자에게는 보이지 않는 숨김 영역이다.

## 2. 프로세스의 생성과 복사

프로세스는 프로그램을 실행할 때 새로 생성된다. 사용자가 프로그램을 실행하면 운영체제는 프로그램을 메모리로 가져와 코드 영역에 넣고 프로세스 제어 블록(PCB)을 생성한다. 그리고 메모리에 데이터 영역과 스택 영역을 확보한 후 프로세스를 실행한다.

프로세스를 새로 생성하는 방법뿐만 아니라 실행 중인 프로세스로부터 새로운 프로세스를 **복사**하는 방법도 있다.

### 🔆 fork 시스템 호출

- fork는 실행 중인 프로세스를 복사하는 함수
- 실행하던 프로세스는 부모 프로세스, 생성된 프로세스는 자식 프로세스로서 부모-자식 관계가 된다.
- 프로세스 제어 블록을 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어진다. 단, PID, (메모리의 위치가 다르므로) 메모리 관련 정보, PPID, PCID 가 다르다.
- 부모 프로세스와 자식 프로세스는 독립적이다.

<img src="https://user-images.githubusercontent.com/89509857/205192056-eb2264b3-4dde-48ff-8a6a-b45d4efd2c6c.png" width="700">

✅ 장점

- 프로세스의 생성 속도가 빠르다
  - 하드 디스크로부터 프로그램을 새로 가져오지 않고 기존 메모리에서 복사했기 때문에 자식 프로세스의 생성속도가 빠르다.
- 추가 작업 없이 자원을 상속할 수 있다
  - 예를 들어 부모 프로세스가 파일 A를 사용하기 위해 초기화했다면 자식 프로세스는 파일 A를 바로 사용할 수 있다.
- 시스템 관리를 효율적으로 할 수 있다.
  - 부모 프로세스와 자식 프로세스가 CPID와 PPID 로 연결되어있기 때문에 자식 프로세스를 종료하면 자식이 사용하던 자원을 부모 프로세스가 정리할 수 있다. 프로세스를 종료하면 프로세스가 사용하던 메모리, 파일, 하드웨어를 정리해야 하는데, 이러한 정리를 부모 프로세스에 맡김으로써 시스템이 효율적으로 관리된다.

## 3. 프로세스의 전환

### 🔆exec 시스템 호출

- 기존의 프로세스를 새로운 프로세스로 전환하는 함수이다.
- 예를 들어, fork 호출이 스파게티에서 스파게티를 하나 더 만드는 호출이라면 exec 호출은 스파게티를 우동으로 바꾸는 호출.
- 프로세스 구조체를 재활용하기 위해 사용 (PCB 과 메모리 영역, 부모-자식 관계)
  - 새로운 프로세스를 만들려면 PCB를 만들고, 메모리 자리를 확보하고, 상위 프로세스와 부모-자식 관계를 만들어야 한다. 이때 exec() 호출을 사용하면 이미 만들어진 것을 그대로 사용할 수 있어 편리하다.
- 기존의 코드영역과 데이터 영역을 지우고 새로운 코드와 데이터로 채운다. 그리고 스택 영역은 리셋한다. 마치 프로세스를 처음 시작하는 것처럼 내용이 정리되는 것이다.

<img src="https://user-images.githubusercontent.com/89509857/205192065-e86fbba6-d886-4e1b-868d-4609d318dfd8.png" width="700">

<br>

# 8️⃣ 스레드(Thread)

- 프로세스를 구성하는 실행의 흐름 단위
- 프로세스의 코드에 정의된 절차에 따라 CPU에 작업을 요청하는 실행단위.
- 기본적으로 하나의 프로세스는 하나의 스레드를 가진다.
- 하나의 프로세스는 여러 개의 스레드를 가질 수 있고, 그러면 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있다.
- 한 프로세스 안에서도 여러 갈래의 작업 흐름이 있는데, 이를 각각 스레드라고 한다.
- ex) 유투브에 들어가면 재생할 영상을 받아올 수도 있어야 하고, 재생도 할 수 있어야하고, 댓글 확인과 작성도 할 수 있어야 하고, 그리고 이 모든 것들이 동시에 진행되어야 한다.
- 프로세스끼리는 기본적으로 자원을 공유하지 않지만, 스레드끼리는 같은 프로세스 내의 자원을 공유한다.

✅ 프로세스의 작업 과정 살펴보기

- 운영체제는 코드와 데이터를 메모리에 가져온 후 PCB를 생성한다.
- 작업에 필요한 메모리 영역을 확보한 후, 준비된 프로세스를 준비 큐에 삽입한다.
- 프로세스가 생성되면 CPU 스케쥴러는 프로세스가 해야할 일을 CPU에 전달하고 실제 작업은 CPU가 실행한다.
- 이때 CPU 스케쥴러가 CPU에 전달하는 일 하나가 스레드이다.

➡ 운영체제 입장에서의 작업 단위는 프로세스이고, CPU 입장에서의 작업 단위는 스레드이다.

## 멀티프로세스 vs 멀티스레드

- 멀티 프로세스 : 프로세스를 동시에 실행하는 것
- 멀티 스레드 : 여러 스레드로 프로세스를 동시에 실행하는 것

<img src="https://user-images.githubusercontent.com/89509857/205047634-80ca59e2-bb16-4926-9f73-4df90b5c937b.png" width="700">

왼쪽은 여러 프로세스로 병행 실행을 하였고, 오른 쪽은 여러 스레드로 병행 실행을 하였다. 그리고 둘은 똑같이 hello를 세 번씩 출력한다. 무슨 차이점이 있을까??

💥 큰 차이점은 프로세스끼리는 기본적으로 자원을 공유하지 않지만, 스레드끼리는 같은 프로세스 내의 자원을 공유한다는 점이다.

<img src="https://user-images.githubusercontent.com/89509857/205223718-3b58f7eb-dce8-4730-84a8-8fa23d0f2dab.png" width="700">

- 프로세스를 fork 하여 동일한 프로세스 두 개를 동시에 실행하면 코드영역, 데이터 영역, 힙 영역 등을 비롯한 모든 자원이 복제되어 메모리에 적재된다.
- 즉, PID, 저장된 메모리 주소를 제외하면 모든 것이 동일한 프로세스 두 개가 통째로 메모리에 적재되는 것.

<img src="https://user-images.githubusercontent.com/89509857/205223988-a1cef9a2-48e8-4e3f-b6ac-3c96e68ada90.png" width="700">

- 스레드들은 각기 다른 스레드 ID, 프로그램 카운터 값을 포함한 레지스터 값, 스택을 가질 뿐 프로세스가 가지고 있는 자원을 공유한다.

- 즉, 여러 프로세스를 병행 실행하는 것보다 메모리를 더 효율적으로 사용할 수 있다.
- 또한 스레드는 프로세스의 자원을 공유하기 때문에 서로 협력과 통신에 유리하다.

## 멀티프로세스

- 다수의 CPU를 이용하여 다수의 작업(프로세스)을 동시에 처리하는(병렬처리) 작업 환경.
- 하나의 컴퓨터에 여러 개의 CPU 또는 하나의 CPU 내 여러 개의 코어에 스레드를 배정하여 동시에 작동하는 것.

### ✅ 장점

- 독립된 구조로 안정성이 높다
  - 여러 개의 프로세스 중 하나에 문제가 발생하면 그 프로세스만 죽고 다른 영향이 확산되지 않는다.

### ✅ 단점

- 문맥 교환 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생한다.
- 프로세스 간에는 기본적으로 자원을 공유하지 않기 때문에 자원 공유를 위해서는 IPC 라는 어렵고 복잡한 통신 기법을 사용해야 한다.

## 멀티스레드

- 프로세스 내 작업을 여러 개의 스레드로 분할하여 작업의 부담을 줄이는 프로세스 운영 기법
- 윈도우, 리눅스 등 많은 운영체제 들이 멀티 프로세싱을 지원하고 있지만 멀티 스레딩을 기본으로 하고 있다.
- 웹 서버는 대표적인 멀티 스레드 응용 프로그램이다.

### ✅장점

- 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다
- 스레드 간 데이터를 주고 받은 것이 간단해지고 시스템 자원 소모가 줄어든다
- 문맥 교환이 빠르다
- 스레드는 프로세스 내의 stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다

### ✅단점

- 주의 깊은 설계가 필요하고 디버깅이 까다롭다.
- 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.

❌예시❌

IE의 경우에는 하나의 프로세스에 멀티 스레드를 사용했고, 크롬은 멀티 프로세스를 이용한다.
<br>
IE에서 여러 개의 화면을 동시에 띄웠는데 그 중 하나가 문제가 생겼고, 문제가 있는 화면을 강제 종료하면 그 화면만 사라지는 것이 아니라 IE 전체가 종료된다. <br>
워드프로세스를 여러 개 띄워놓고 사용하다가 한 문서에 문제가 생기면 워드프로세서 전체가 종료 되는 것도 이와 같은 현상이다.
<br>
한편 크롬은 각 화면이 독립적인 프로세스이므로 그중 하나가 문제가 생겨서 종료해도 다른 화면에 미치는 영향이 적다.
