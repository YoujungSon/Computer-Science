# 프로세스(Process)

- 프로세스의 개념
- 일괄 작업 방식 vs 시분할 방식
- 프로그램에서 프로세스로의 전환
- 프로세스의 상태
- 프로세스 제어 블록
- 문맥 교환

# 1️⃣ 프로세스의 개념

- 운영체제에서 프로세스는 하나의 작업 단위이다.
- 사용자가 마우스를 더블클릭 하여 프로그램을 실행하면 그 프로그램은 프로세스가 된다.
- 프로그램과 프로세스의 차이는?
- 폰노이만 구조 : "모든 프로그램은 메모리에 올라와야 실행할 수 있다."
  - 폰노이만 구조 : CPU, 메모리, 입출력장치, 저장장치가 버스로 연결되어 있는 구조로 오늘날의 컴퓨터는 대부분 폰노이만 구조를 따른다
- 프로그램은 저장장치에 저장되어 있는 정적인 상태, 프로세스는 실행을 위해 메모리에 올라온 동적인 상태

# 2️⃣ 일괄 작업 방식 vs 시분할 방식

## ✅ 일괄 작업 방식

- 한 번에 한 가지 작업만 가능한 방식.
- 하나의 작업을 읽어들여 실행하고, 결과를 출력한 후에 다음 작업을 읽어들여 실행하는 방식이다.
- 모든 작업을 한꺼번에 처리해야 하고, 프로그램 실행 중간에 사용자가 데이터를 입력하거나 수정하는 것이 불가능하다. => 일괄 작업 시스템(batch job system), 일괄 처리 시스템(batch processing system)

## ✅ 시분할 방식

- 현대의 운영체제는 시분할 방식을 기본으로 사용한다.
- 오늘날의 컴퓨터에도 대부분 시분할 시스템이 사용된다.
- 다중 프로그래밍, 하나의 CPU 로 여러 작업을 동시에 실행하는 기술로 효율성이 뛰어나다.
- 그런데 여러 작업이 하나의 CPU를 공동으로 사용하면 작업이 끊겨 보일 텐데 다중 프로그래밍 시스템에서는 여러 작업이 동시에 실행되는 것처럼 보인다. 어떻게 가능한 걸까?
- 시간을 분할하는 방법 때문이다!
- 다중 프로그래밍 시스템에서는 CPU 사용 시간을 아주 잘게 쪼개어 여러 작업에 나누어준다.
- 예를 들어, 각 작업에 1초씩 할당하면 작업이 끊어지면서 실행되겠지만, 0.1초씩 할당한다면 A 작업에 0.1초, B 작업에 0.1초, C작업에 0.1초를 돌아가며 배정하여 A 작업은 0.3초 뒤에 다시 CPU를 얻어 작업할 수 있다. 이렇게 시간분배가 매우 빠른 속도로 반복되면 A, B, C가 동시에 실행되는 것처럼 보인다.
- 이때 잘게 나눈 시간 한 조각을 타임 슬라이스(time slice) 또는 타임 퀀텀(time quantum)이라고 한다.

# 3️⃣ 프로그램에서 프로세스로의 전환

- 프로세스는 컴퓨터 시스템의 작업 단위로 태스크(task)라고도 부른다.
- 우선 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다.
- 그와 동시에 프로세스 제어 블록(PCB, process control block)을 만든다.
  - 프로세스를 처리하는 데 필요한 다양한 정보가 들어있고, 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 못한다. 어떤 프로그램이 프로세스가 되었다는 뜻은 운영체제로부터 프로세스 제어 블록을 받았다는 의미이다.
- 프로세스 제어 블록은 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에, 운영체제 영역에 만들어 진다.
- 프로세스가 종료되면 프로세스가 메모리에서 삭제되고 프로세스 제어 블록도 폐기된다.
  <img src="https://user-images.githubusercontent.com/89509857/203506702-cc064b1d-94f1-4f4f-8ed8-c46b6be29b44.png" width="700">
- 잊지 말아야 할 점은, 운영체제도 프로그램이기 때문에 프로세스 형태로 실행되어야 한다는 사실이다.
  - 컴퓨터를 켰을 때 운영체제를 메모리에 올리는 과정을 부팅(booting)이라고 한다.
  - 부트스트랩(bootstrap): 운영체제를 메모리로 가져와 실행하는 역할을 하는 작은 프로그램

### 프로세스와 프로그램의 관계

프로세스 = 프로그램 + 프로세스 제어 블록
<br/>
프로그램 = 프로세스 - 프로세스 제어 블록

# 4️⃣ 프로세스의 상태

운영체제에서도 여러 가지 이유로 프로세스의 상태(process status)가 변화한다.

- 일괄 작업 시스템에서 프로세스 상태는 생성(crate), 실행(run), 완료(terminate) 이다.
- 시분할 시스템에서의 프로세스 상태는 일괄 작업 시스템보다 복잡하다. CPU를 얻어 실행 중인 프로세스가 중간에 다른 프로세스에 CPU를 넘겨주는 일이 빈번하기 때문이다.

## 프로세스의 네 가지 상태

<img src="https://user-images.githubusercontent.com/89509857/203509974-4e386f64-f292-4ed3-892d-8b75555cca8f.png" width="700">

- **생성 상태(create status)** : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태, 프로세스를 관리하는 데 필요한 프로세스 제어 블록이 생성된다.
- **준비 상태(ready status)** : 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태. CPU가 하나인 컴퓨터에서는 한 번에 하나의 프로세스만 실행할 수 있기 때문에 자기 실행 순서가 될 때까지 준비 상태에서 기다려야한다.
- **실행 상태(running stauts)** : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태로 execute status라고 표현하기도 한다. 실행 상태에 들어간 프로세스는 일정 시간 동안 CPU를 사용할 권리를 갖는다. 만약 주어진 시간을 다 사용하고도 작업이 끝나지 않았다면(time out) 프로세스는 준비 상태로 돌아와 다음 차례를 기다린다. 프로세스는 자신의 작업이 끝날 때까지 준비 상태와 실행 상태를 왔다갔다 한다.
- **완료 상태(termintae status)** : 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입한다. 완료 상태는 프로세스 제어 블록이 사라진 상태를 의미한다.
- 준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 CPU 스케쥴러(CPU scheduler)가 담당한다.
- CPU 스케쥴러는 전 상태, 즉 생성, 준비, 실행, 완료에 관여하여 모든 프로세스의 작업이 원만하게 이루어지도록 관리한다.

## 프로세스의 다섯 가지 상태

프로세스는 생성, 준비, 실행, 완료라는 네 가지 상태만으로 작업을 진행하는 데 큰 문제가 없다. 그러나 오늘날 운영체제의 효율성을 고려하여 한 가지 상태를 더 만들었다.

- 어떤 프로세스가 실행 상태에 들어가 입출력을 요구했다고 가정해보자.
- 이때 CPU가 직접 데이터를 가져오지 않고 입출력 관리자에게 명령을 내린다. 이 상태에서 프로세스는 요청한 작업이 끝날 때까지 다음 작업을 할 수 없어 효율성이 떨어진다.
  => 대기 상태
- 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태를 '대기 상태(blocking status)라고 한다.

<img src="https://user-images.githubusercontent.com/89509857/203510087-e3ef6514-2456-4266-994f-5c0049da723f.png" width="700">

- 입출력을 요청한 프로세스가 대기 상태로 옮겨지면 CPU 스케쥴러는 준비 상태에 있는 프로세스 중 하나를 가져다 실행 상태로 만든다. 그러면 시스템 입장에서는 새로운 작업을 진행하게 되어 효율성이 높아진다.
- 대기 상태의 프로세스는 입출력이 완료되면 실행상태로 돌아가는 것이 맞지만, 그러려면 현재 실행 상태에서 작업 중인 프로세스를 준비 상태로 돌려야 하고, 두 프로세스의 상태를 변화시키는 건 복잡한 상황이므로 대기 상태에서 입출력이 끝난 프로세스는 실행 상태로 가지 않고 준비 상태로 돌아가 자기 차례를 기다린다.

## 휴식 상태와 보류 상태

대부분의 프로세스는 생성, 준비, 실행, 대기, 완료 상태로 운영되며 이 다섯 가지 상태를 활성 상태(active status)라고 한다. 그리고 활성 상태 외에 또 다른 상태가 있다.

### ✅ 휴식 상태

- 휴식 상태는 프로세스가 작업을 일시적으로 쉬고 있는 상태
- 유닉스에서 `ctrl + z` 키를 눌러 휴식 상태로 들어갈 수 있다.
- 사용하던 데이터가 메모리에 그대로 있고, 프로세스 제어 블록도 유지되므로 프로세스는 멈춘 지점에서부터 재시작(resume) 할 수 있다.

  <img src="https://user-images.githubusercontent.com/89509857/203657716-c4eb8a3f-e3dd-4c3f-8247-f2985e80e666.png" width=600>

  - jobs : 상태 확인, bg: background로 실행

- 프로세스의 상태가 정지 임을 알 수 있다. 정지는 휴식 상태의 예이다.
- 유닉스에서 `ctrl+c`를 누르면 프로그램을 강제 종료 할 수 있다. 이때는 메모리에서 사라지고 프로세스 제어 블록도 사라지기 때문에 사용하던 데이터를 잃어버리고, 처음부터 다시 시작해야한다.

### ✅ 보류 상태

- 보류 상태는 프로세스가 메모리에서 잠시 쫓겨난 상태로, 휴식 상태와 차이가 있다.
- 보류 상태를 '일시 정지 상태'라고도 불리며, 보류 상태와 비교하여 일반적인 프로세스 상태를 활성상태라고 한다.

```
다음과 같은 경우에 보류 상태가 된다.
- 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때.
- 프로그램에 오류가 있어서 실행을 미루어야 할 때
- 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
- 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
- 입출력을 기다리는 프로세스의 입출력이 계속 지연될 떄
```

<img src="https://user-images.githubusercontent.com/89509857/203510102-a849f56b-df24-45c3-a960-40a46a97c204.png" width=700>

- 보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑영역(swap area)에 보관된다
  - 스왑 영역은 메모리에서 쫓겨난 데이터가 임시로 보관되는 장소
- 보류 상태는 대기 상태에서 옮겨진 '보류 대기 상태' 와 준비 상태에서 옮겨진 '보류 준비 상태'로 구분된다.
- 재시작 하면 원래의 활성 상태로 돌아간다.
- 보류 대기 상태에서 입출력이 완료되면 활성상태가 아닌 보류 준비 상태로 옮겨진다.

# 5️⃣ 프로세스 제어 블록(PCB, Process Control Block)

-프로세스 제어 블록은 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료구조

- TCB(Task Control Block)이라고도 부른다.

## 프로세스 제어 블록의 구성

1. 포인터 : PCB의 첫 번째 블록에는 포인터가 저장된다. 준비 상태나 대기 상태는 큐로 운영되는데, 큐를 구현할 때 포인터를 사용한다.
2. 프로세스 상태 : PCB 두 번째 블록에는 프로세스 상태가 저장된다. 프로세스가 현재 어떤 상태에 있는지 나타낸다.
3. 프로세스 구분자 : PID(Process ID), 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자
4. 프로그램 카운터 : 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값을 저장
5. 프로세스 우선 순위 : 프로세스의 중요도가 각각 다르고, 사용자 프로세스보다 커널 프로세스가 우선순위가 더 높고, 사용자 프로세스끼리도 우선순위가 다르다. 따라서 대기 상태의 큐도 우선순위 별로 따로 운영된다.
6. 각종 레지스터 정보 : 프로세스가 실행되는 중에 사용하던 레지스터 값이 저장된다.
7. 메모리 관리 정보 : 프로세스가 메모리의 어디에 있는지 나타내는 메모리 위치 정보, 경계 레지스터 값과 한계 레지스터 값 등이 저장된다. 그 외 세그멘테이션 테이블, 페이지 테이블 등의 정보도 보관한다.
8. 할당된 자원 정보 : 프로세스를 실행하기 위해 사용되는 입출력 자원이나 오픈 파일 등에 대한 정보를 말한다.
9. 계정 정보 : 계정 번호, CPU 할당 시간, CPU 사용 시간 등
10. 부모 프로세스 구분자와 자식 프로세스 구분자 : 부모 프로세스를 가리키는 PPID(Parent PID) 와 자식 프로세스를 가리키는 CPID(Child PID)정보가 저장된다.

# 6️⃣ 문맥 교환

- 문맥 교환은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다.
- 실행 상태에서 나가는 프로세스 제어 블록에는 지금까지의 작업 내용을 저장하고, 실행 상태로 들어오는 프로세스 제어 블록의 내용으로 CPU가 다시 세팅된다.

<img src="https://user-images.githubusercontent.com/89509857/203663297-45cc12e6-a2be-4e79-bb02-e39b935450b8.png" width=600>

문맥 교환이 일어나는 경우
```
- 한 프로세스가 자신에게 주어진 시간을 다 사용했을 때
- 인터럽트가 걸렸을 때
```
