# HTTP란?

Hypertext Transfer Protocol

서로 다른 시스템들 사이에서 통신을 주고받게 하는 가장 기본적인 프로토콜

서버에서 브라우저로 데이터를 전송하는 용도로 가장 많이 사용합니다.

한편 HTTP는 서버에서 브라우저로 전송되는 정보가 **암호화되지 않는다는 문제점**을 가지고 있습니다. 그래서 데이터가 쉽게 도난 당할 수 있습니다.

# HTTPS란?

Hypertext Transfer Protocol Secure

## **HTTPS: 하이퍼 텍스트 전송 프로토콜 보안(Hyper Text Transfer Protocol Secure)**

웹사이트가 SSL/TLS 인증서로 보호되는 경우 HTTPS가 URL에 표시됩니다.
사용자는 브라우저 표시줄의 자물쇠 기호를 클릭해 발급 기관 및 웹사이트 소유자의 상호를 포함한 인증서의 세부 정보를 볼 수 있습니다.

# 왜 HTTP가 아닌 HTTPS를 사용해야 할까요?

## 1. 보안성

![image](https://user-images.githubusercontent.com/88040809/205275774-24011b74-cc78-479c-96fc-f8386184ee65.png)

**HTTP로 데이터를 전송하는 경우**

데이터를 전송하면 네트워크로 전달되는 데이터는 원본 그 자체입니다.
그래서 해커가 중간에서 가로챈 후 이 데이터를 보면 해당 데이터에 어떤 내용이 있는지 바로 알 수 있습니다.
다음으로 HTTPS로 데이터를 전송하는 경우를 살펴보겠습니다.

**HTTPS로 전송하는 경우**

데이터를 암호화해서 전송합니다. 그래서 해커가 중간에 데이터를 가로채도 데이터는 암호화 되어 있기 때문에 이 데이터가 어떤 내용을 가지고 있는지는 알기 어렵습니다.
그래서 HTTP가 아닌 HTTPS로 데이터를 전송해서 보안성을 확보해야 합니다.

## 2. SEO(검색엔진 최적화)

2014년에 Google은 웹 전반의 보안을 개선하기 위해 모든 사이트에 HTTPS를 요구했습니다.
그리고 SSL 보안 사이트에 대해 높은 검색 순위로 보상했습니다.
2018년에 구글은 검색 순위 보상을 넘어 SSL 인증서가 없는 사이트에게 불이익을 주기 시작했습니다.
해당 사이트는 Chrome 브라우저에 "안전하지 않음"이라고 표시됩니다.

# SSL 과 TLS

## **SSL: 보안 소켓 계층(SECURE SOCKETS LAYER)**

SLL은 서버와 브라우저 사이에 안전하게 암호화된 연결을 만들 수 있게 도와주고, 서버와 브라우저가 민감한 정보를 주고 받을 때 해당 정보가 도난 당하는 것을 막아줍니다.

## **TLS: 전송 계층 보안(Transport Layer Security)**

TLS은 SSL의 향상된, 더욱 안전한 버전입니다.

HTTPS는 HTTP 자체를 암호화하는 것은 아닙니다.
HTTP를 사용해서 운반하는 내용, 즉 HTTP Message Body를 암호화합니다.
이때, HTTP Header는 암호화되지 않습니다.

‘Let’s Encrypt’와 ‘AWS Certificate Manager’는 SSL 인증서를 무료로 발급해주는 서비스입니다.

# SSL이란

Secure Sockets Layer

Netscape Communications Corporation에서 웹 서버와 웹 브라우저 간의 보안을 위해 만든 프로토콜

공개키(공개키 / 개인키) , 대칭키 방식을 혼합해서 사용합니다.

# 대칭키 방식

대칭키는 이름에서 알 수 있듯이, 어떤 정보를 암호화·복호화 할 때 사용하는 키가 동일(대칭)한 경우 입니다.
![image](https://user-images.githubusercontent.com/88040809/205275916-866c872e-b5c9-4da8-a88b-bcbc38f02da3.png)

즉, 암호화할 때 필요한 키값과, 해당 정보를 복호화할 때 필요한 키값이 동일한 경우입니다.

어떠한 정보가 대칭키를 통해 암호화 되었다면, 똑같은 키를 갖고 있는 사용자가 아니면 해당 정보를 확인할 수 없습니다.

따라서 암호화 된 정보를 전달하고 확인하기 위해서는 송·수신자 둘 다 똑같은 키를 가지고 있어야 합니다.

이러한 키를 안전하게 교환하는 것이 대칭키 암호화 방식의 가장 중요한 부분이라 할 수 있습니다.

이처럼 대칭키 암호화 방식은 키가 없다면 누구도 열어볼 수 없어 안전하지만, 이 키를 안전하게 전달하는 것이 핵심이라 할 수 있습니다.

- 예시
  부산에 살고 있는 철수는 A라는 열쇠로만 열 수 있는 보물상자를 서울에 있는 영희에게 안전하게 전달하고자 합니다. 그렇다면 철수는 보물상자를 영희에게 보내는 것은 물론이고, 이 상자를 열 수 있는 A 열쇠 또한 안전하게 영희에게 전달해야 합니다.
  만약 보물상자와 함께 열쇠를 담아 보낸다면, 중간에 다른 사람이 가로채 상자를 열어볼 수 있게 됩니다.
  따라서 이 열쇠는 보물상자와는 다른 경로로 안전하게 영희에게 전달되어야 합니다.

### 장점

**암호화 방식에 속도가 빠르다.** **대용량 Data 암호화**에 적합하다.

### 단점

키를 교환해야 하는 문제, **탈취 관리 걱정**, 사람이 증가할수록 키 관리가 어려워짐, 확장성 떨어짐

Session Key, Secret Key, Shared Key, 대칭키, 단용키라고도 함

**기밀성을 제공**하나, **무결성/인증/부인방지 를 보장하지 않음**

대표적 알고리즘 : 공인 인증서의 암호화 방식으로 유명한 **SEED**, DES, 3DES, AES, ARIA, 최근 주목받고 있는 암호인 ChaCha20

# 공개키(비대칭키) 방식

비대칭키 또한 이름에서 알 수 있듯이, 어떠한 암호화·복호화를 할 때 사용하는 키가 서로 다른 경우를 의미합니다.
![image](https://user-images.githubusercontent.com/88040809/205275972-650248eb-592f-45af-8ac3-7a875e6a730d.png)

대칭키와 다르게 비대칭키를 활용한 암호화에는 개인키와 공개키 두 가지가 사용됩니다.

또한, 비대칭키를 활용한 암호화는 개인키로 암호화하는 방식과 공개키로 암호화하는 방식 두 가지로 나뉘게 됩니다.

## 1) 공개키로 정보를 암호화하는 경우(암호 모드)

송신자 공개키로 암호화 -> 송신자 사설키로 복호화 소량의 메시지 암호화 목적, 주로 키 교환의 용도로 사용

공개키는 누구나 알 수 있도록 공개된 키이므로, 어떤 정보를 특정 사용자에게 보낼 대 사용자의 공개키를 통해 정보를 암호화하여 전송합니다.

위에서 언급한 대칭키에서의 키값 교환에 따른 문제를 해결한 방법이라고 볼 수 있습니다.

- 예시
  부산에 살고 있는 철수는 누구나 알 수 있는 영희의 공개키를 통해 보물상자를 암호화 한 후 영희에게 보냅니다.
  이 보물상자는 영희의 공개키로 암호화 되었기 때문에 열어보기 위해서는 영희의 개인키가 필요합니다. (공개키로 암호화 되었다면 개인키로 해제할 수 있습니다. 공개키로 해제는 불가능합니다.)
  하지만 영희의 개인키는 영희 자기자신만 가지고 있기 때문에, 받아 본 보물상자를 안전하게 열어볼 수 있습니다.

## 2) 개인키로 정보를 암호화하는 경우(인증 모드)

송신자 사설키로 암호화 -> 송신자 공개키로 복호화 메시지를 인증(부인방지)하는 것이 목적

개인키는 자신만이 가지고 있는 키이므로, 어떠한 정보를 특정 사용자에게 보낼 때 자기자신의 개인키를 통해 정보를 암호화하여 전송합니다.

- 예시
  부산에 살고 있는 철수는 자신만의 개인키를 통해 보물상자를 암호화하여 영희에게 보냅니다.
  이 보물상자는 철수의 개인키를 통해 암호화 되었기 때문에, 철수의 공개키가 있어야만이 열어볼 수 있습니다.
  하지만 철수의 공개키는 누구나 알 수 있도록 공개가 되어 있습니다.
  따라서 영희는 보물상자를 받아 본 후 공개되어있는 철수의 공개키를 통해 보물상자를 열어볼 수 있습니다.

이 방법은 ‘보물상자안에 뭐가 들었냐’보다는 ‘이 보물상자를 누가 보냈냐’에 초점을 둔 방법입니다.

즉, 철수의 개인키로 암호화한 보물상자는 철수의 공개키를 통해서만 열어볼 수 있기 때문에, 만약 어떤 보물상자가 철수의 공개키로 열린다면, 이 보물상자는 철수가 보낸게 확실하다는 뜻입니다.

이러한 기술은 데이터 제공자의 신원이 보장되는 ‘전자서명’ 등의 공인인증체계의 기본이 됩니다.

### 단점

**속도가 느림**

### 장점

키 분배 필요 X, **기밀성/인증/부인방지 기능 제공**

대표적인 알고리즘

- **Diffie Hellman** : 최초의 공개키 알고리즘, 위조에 취약
- **RSA** : 대표적 공개키 알고리즘
- **DSA** : 전자서명 알고리즘 표준
- **ECC** : 짧은 키로 높은 암호 강도, 빠른 구현 가능 PDA, 스마트폰등에 사용

그래서 SSL은 각 방식이 가진 단점 때문에 한 방식만 채택해서 사용하지 않고 두 방식을 모두 적절히 섞어 사용합니다.

그렇다면 SSL은 왜 필요할까요?

HTTPS를 설명할 때도 말한 것처럼 서버와 브라우저간 전송되는 데이터를 외부의 공격자로부터 보안하기 위해 필요합니다. 결국 보안이 가장 중요한 키워드입니다.

암호화의 대상은 내용이 유출됐을 때 자칫 악용되어 사용될 수 있는 비밀번호나 개인 정보 등이 해당됩니다.

# SSL 통신 방식 (SSL Hand Shake)

![image](https://user-images.githubusercontent.com/88040809/205276010-cdf2dbd8-6d93-47fc-b1bb-a071cf734e20.png)

## 1. **CA 인증서 발급**

1. 웹서비스를 제공하는 회사에서 Site 정보 & 공개키를 인증기관에 제공하여 인증요청
2. 인증기관은 해당 정보를 기관의 개인키(비공개키)로 암호화하여 인증서를 생성하고 요청한 회사로 발급
3. 인증기관은 해당 인증서의 공개키를 Browser에 제공
4. SSL 통신을 위한 준비 완료

## 2. **SSL Hand Shake**

- Client 와 Server가 대칭키를 얻기위한 절차로 아래의 과정으로 진행됩니다.

### Client Hello

- Client는 임의 데이터를 만들어 Server에 전송
- Client가 사용 가능한 암호화 알고리즘 (Cipher Suite)를 Server에 전송

### Server Hello

- Server도 마찬가지로 임의 데이터를 만들어 Client에게 전송합니다.
- Client로부터 받은 암호화 알고리즘 (Cipher Suite) 중 사용할 알고리즘을 선택하여 Client에게 전송합니다.

### Certificate

- Server는 CA 인증서를 Client에게 전달합니다.
- Client는 Server로 부터 받은 CA 인증서를 공개키로 복호화 하여 Server의 신원을 확인하고 Server 정보 및 Server 공개키를 획득합니다.

Client Key Exchane

- Client는 임의로 만든 데이터(Client 및 Server)를 조합하여 임시 Key를 만들고 이를 Server 공개키로 암호화하여 전달합니다.
- Server는 암호화된 임시 Key를 전달받고 이를 개인키로 복호화하여 임시 Key를 획득합니다.

### ChangeCipherSpec / Finished

- Client와 Server 모두 동일한 Key(대칭키)를 소유하고 이를 사용하여 통신을 할 수 있게 됩니다.
